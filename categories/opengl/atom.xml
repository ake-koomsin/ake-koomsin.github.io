<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: opengl | Ake Koomsin]]></title>
  <link href="http://ake.in.th//categories/opengl/atom.xml" rel="self"/>
  <link href="http://ake.in.th/"/>
  <updated>2016-01-09T21:43:41+09:00</updated>
  <id>http://ake.in.th/</id>
  <author>
    <name><![CDATA[Ake Koomsin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Offscreen Rendering and Multisampling with OpenGL]]></title>
    <link href="http://ake.in.th/2013/04/02/offscreening-and-multisampling-with-opengl/"/>
    <updated>2013-04-02T17:10:00+09:00</updated>
    <id>http://ake.in.th/2013/04/02/offscreening-and-multisampling-with-opengl</id>
    <content type="html"><![CDATA[<p>It has been for a while since my last post. I was enjoying with my senior project, &ldquo;Accelerating Map Rendering with GPU&rdquo;. In this project, my friend and I modified Mapnik, an opensource map rendering, to utilize Nvidia&rsquo;s <a href="https://developer.nvidia.com/nv-path-rendering" title="Nvidia's Path Rendering">Path Rendering</a>. Path Rendering is an OpenGL extension provided by Nvidia for vector graphic rendering. Nvidia <a href="http://dl.acm.org/citation.cfm?id=2366191" title="GPU-accelerated path rendering paper">claims</a> that its extensions aims to reduce overhead from traditional APIs when using them to draw vector graphics. In the end, we are able to make the map production 30-60% faster. Our implementation can be found on <a href="https://github.com/ake-koomsin/mapnik_nvpr">https://github.com/ake-koomsin/mapnik_nvpr</a></p>

<p>There are two important things that we had to achieve in order to use Path Rendering extension for map rendering, offscreen rendering and multisampling. Offscreen rendering is important because we don&rsquo;t want the renderer to show the intermediate result. Multisampling is for producing a quality map.</p>

<p>I think offscreen rendering combining with multisampling is an important piece of knowledge. It is also hard to find a complete refernce about these two. Therefore, I think it is worth writing about it.</p>

<h2>Offscreen Rendering</h2>

<p>Offscreen rendering is a technique that are commonly found in game development. Sometimes, there are situations that you want to generate a texture at runtime.</p>

<p>To set up offscreen rendering, you have to create your own &ldquo;Framebuffer Object (FBO)&rdquo;. Actually, OpenGL has its own default FBO. A result stored in the default FBO will be shown onto the screen while the result stored in our own FBO will be not. The code below demonstrates how to set up our own FBO.</p>

<p>``` c Setting our own FBO for offscreen rendering
int fbo, colorBuffer, depthBuffer;</p>

<p>// Create and bind the FBO
glGenFramebuffers(1, &amp;fbo);
glBindFramebuffer(GL_FRAMEBUFFER, fbo);</p>

<p>// Create color render buffer
glGenRenderbuffers(1, &amp;colorBuffer);
glBindRenderbuffer(GL_RENDERBUFFER, colorBuffer);
glRenderbufferStorage(GL_RENDERBUFFER, GL_RGBA8, width, height);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, colorBuffer);</p>

<p>// Create depth render buffer (This is optional)
glGenRenderbuffers(1, &amp;depthBuffer);
glBindRenderbuffer(GL_RENDERBUFFER, depthBuffer);
glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, width, height);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthBuffer);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, depthBuffer);</p>

<p>// Bind Texture assuming we have created a texture
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, aTexture, 0);</p>

<p>// Draw something
drawGraphic();
```</p>

<p>It is straightforward. First, we create a FBO. After that, we create render buffers and textures and attach them to our FBO.</p>

<h2>Multisampling</h2>

<p>By default, OpenGL does not care about antialiasing. As a result, the output contains stair-like artifacts which degrade visual quality. We have to enable multisampling by the code below.</p>

<p><code>c Enabling multisampling
glEanble(GL_MULTISAMPLE);
</code></p>

<h2>Combining Offscreen Rendering and Multisampling Together</h2>

<p>It turns out that to combine them together, we need additional set up which are multisample framebuffer storage and multisample texture. The code below demonstrates how to do.</p>

<p>``` c Setting up FBO with Multisampling</p>

<p>// Create multisample texture
glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, aMultisampleTexture);
glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, 16, GL_RGBA, width, height, GL_TRUE);</p>

<p>int fbo, colorBuffer, depthBuffer;</p>

<p>// Create and bind the FBO
glGenFramebuffers(1, &amp;fbo);
glBindFramebuffer(GL_FRAMEBUFFER, fbo);</p>

<p>// Create color render buffer
glGenRenderbuffers(1, &amp;colorBuffer);
glBindRenderbuffer(GL_RENDERBUFFER, colorBuffer);
glRenderbufferStorageMultisample(GL_RENDERBUFFER, 16, GL_RGBA8, width, height);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, colorBuffer);</p>

<p>// Create depth render buffer (This is optional)
glGenRenderbuffers(1, &amp;depthBuffer);
glBindRenderbuffer(GL_RENDERBUFFER, depthBuffer);
glRenderbufferStorageMultisample(GL_RENDERBUFFER, 16, GL_DEPTH24_STENCIL8, width, height);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, depthBuffer);
glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, depthBuffer);</p>

<p>// Bind Texture assuming we have created a texture
glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, aTexture, 0);</p>

<p>// Enable multisampling
glEanble(GL_MULTISAMPLE);</p>

<p>// Draw something
drawGraphic();
```</p>

<h2>Retrieving the result</h2>

<p>After offscreen rendering, you may want to display the result onto the screen. When you are using multisampling FBO, you are not able to use the result stored in the texture directly. You have to do &ldquo;Blitting&rdquo; which transfer the result from one FBO to another. The code below shows how to do.</p>

<p><code>c Blitting
glBindFramebuffer(GL_READ_FRAMEBUFFER, multisampledFBO);
glBindFramebuffer(GL_DRAW_FRAMEBUFFER, normalFBO); // Normal FBO can be the default FBO too.
glBlitFramebuffer(0, 0, width, height, 0, 0, width, height, GL_COLOR_BUFFER_BIT, GL_NEAREST);
</code></p>

<p>I hope these snippets are a useful reference.</p>
]]></content>
  </entry>
  
</feed>
